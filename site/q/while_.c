#include<stdio.h>
void test1();
// void test2();
int main() {
    test1();
    // test2();
    return 0;
}
void test1() {
    int cnt = 3;
    while(cnt-- > 0) {
        int i = 1;
        i++;
        printf("i->%d\n", i);
    }
}
// void test2() {  // redefined error
//     int i = 1;
//     i++;
//     printf("i->%d\n", i);
//     int i = 1;
//     i++;
//     printf("i->%d\n", i);
//     int i = 1;
//     i++;
//     printf("i->%d\n", i);
// }
/*
while的多次循环，不能视为一个作用域，而是整个循环过程的一次循环，是一个作用域。
把test1、理解为test2是错误的。

“重定义”是编译期的检查，test1没有编译报错，是因为，test1的写法，语义上没有问题，所以会通过编译。
那么编译期 为什么会认为 test1 的写法是语义正确的？
因为while的多次循环之间在指令层面并没有什么很紧密的联系，因为就是pc跳转罢了
cpu甚至都不知道自己在循环里面，他只知道一条条地执行。

简单来讲就是，编译器认为你每次的i不是同一个i

这段代码是 ARM 架构的汇编语言，使用 AT&T 语法风格。它是 C 语言函数 `_test1` 的汇编表示形式。下面是这段代码的逐行解释：

- `100003f20: d10083ff     sub     sp, sp, #32`：为局部变量和保存寄存器分配栈空间。`sp` 是栈指针，减去32是为了分配32字节的栈空间。

- `100003f24: a9017bfd     stp     x29, x30, [sp, #16]`：保存函数的帧指针（`x29`）和链接寄存器（`x30`）到栈上，偏移量为16字节。

- `100003f28: 910043fd     add     x29, sp, #16`：设置帧指针 `x29` 指向新的栈帧的开始位置。

- `100003f2c: 52800068     mov     w8, #3`：将立即数3移动到寄存器 `w8`。

- `100003f30: b81fc3a8     stur    w8, [x29, #-4]`：将 `w8` 存储到栈帧的-4字节位置。

- `100003f34: 14000001     b       0x100003f38 <_test1+0x18>`：无条件跳转到标签 `_test1+0x18`。

- `100003f38` 到 `100003f48`：循环开始，加载、递减并存储 `w8` 的值。

- `100003f4c: 370001e8     tbnz    w8, #0, 0x100003f88 <_test1+0x68>`：如果 `w8` 的第0位为全1，则跳转到标签 `_test1+0x68`。

- `100003f50` 到 `100003f64`：循环内，增加栈上存储的值。

- `100003f68` 到 `100003f70`：加载栈上的值到 `x8`，准备打印。

- `100003f74: f9000128     str     x8, [x9]`：将 `x8` 的值存储到 `x9` 指向的地址，这里 `x9` 指向栈上的空间。

- `100003f78` 到 `100003f80`：设置参数寄存器 `x0`，准备调用 `_printf` 函数。

- `100003f84: 17ffffed     b       0x100003f38 <_test1+0x18>`：跳回循环开始处。

- `100003f88: a9417bfd     ldp     x29, x30, [sp, #16]`：从栈上恢复帧指针和链接寄存器。

- `100003f8c: 910083ff     add     sp, sp, #32`：恢复栈指针到函数开始前的状态。

- `100003f90: d65f03c0     ret`：从函数返回。

这个函数似乎是一个循环，每次循环递增一个在栈上存储的值，并在某条件下打印这个值。循环使用了一个简单的计数器（在栈上存储），并在每次迭代中递增计数器的值。`_printf` 调用可能是用来输出结果的。

请注意，这些解释是基于代码的直观理解，没有上下文信息或具体的 C 语言源代码，因此某些细节可能不完全准确。


*/