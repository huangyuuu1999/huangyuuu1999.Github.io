# 抽象语法树

当源代码被当做字符串拆解为token序列之后，词法解析器的任务就完成了。下一步需要进行语法分析，也就是从上一步得到的token序列生成ast抽象语法树。

### ast的节点类型

ast抽象语法树，树上的节点有表达式节点、也有语句节点。语句就是token按照一定的规则（语法）组成的句子。

### 如何构建

## 程序语言的语法描述

怎么把语法 用简单的数学符号表示出来。
假设 $ \Sigma $ 是一个字母表，其中字母的数量是有限的。定义从 $\Sigma$ 中取 $n$ 次符号 $ \left(n>0\right)$，依次拼成的串，叫字母表上的字符串，这个字母表能组成很多的字符串，其中，取0个就是空串，计为 $ \varepsilon $ 。

一个字母表或者符号集合上，能有多少种字符串？答案是无穷种。
这个无穷集合记为 $\Sigma^*$ 。
例如 $\Sigma = \left\{a, b\right\}$ ，则对应的无穷集合 $\Sigma^* = \left\{\varepsilon, a,b,aa,bb,ab, aaa, bbb, aab, aba ...\right\}$ 。
如果一个字母表（符号集合）本身就是空集，那么他不能组合出任何的字符串，也就是 $\Sigma =  \left \{ \right \}$ 对应的 $\Sigma^* =  \left \{ \right \}$ ，空集可以简写为 $\phi$ 。
$\Sigma^*$ 是一个无穷集。有限个数的集合，他有无穷多个。

假设 $U$ $V$ 是 $\Sigma$ 的两个子集。 （没有说是有限子集还是无线子集）。


### 上下文无关文法

文法，就是规则。
上下文无关文法，就是只需要看写的内容是不是符合这个规则。不需要管上下文。

一个上下文无关文法 $G$ 包括四个部分：一组终结符号、一组非终结符号、一个开始符号、一组产生式。

终结符号，不能再分的单元，token。有很多种类：关键字、标识符、字面量、运算符、界限符。

非终结符号，算术表达式、布尔表达式、赋值语句、函数等。总之不是终结符号那样的不可再分的东西，并且一个非终结符号代表一个特定的语法概念。（？抽象）

开始符号，是 **一个** 特殊的非终结符号。

产生式（也叫规则）

产生式的形式：
$A \to \alpha $ 。
箭头左边 $A$ 是一个非终结符，箭头右边的 $\alpha$ 是由终结符号（或|与）非终结符号组成的符号串。

箭头右边，可以是一个终结符号、也可以是多个非终结符号的组合、也可以是终结符号和非终结符号的组合。

变量是一个算术表达式、算术表达式之间的四则运算也是算是表达式。


$ E \to i$ 。其中 $i$ 表示变量。

$ E \to E + E$

$ E \to E - E$

$ E \to E * E$

$ E \to E / E$

$ E \to \left( E \right)$

表达式的后面几个都是递归的。

一个上下文无关文法，可以表示为一个四元式 
$\left(V_t, V_n,S,\Psi\right)$ 。
$V_t$ 是非空有限集，是终结符号。终结符号必须非空。
$V_n$是非空有限集，每个元素都是非终结符号，$V_t \bigcap V_n = \phi$ 。
$S$ 是非终结符号，开始符号。
$\Psi$ 是产生式集合，是有限集合，对应了规则。每个产生式的形式都是 $P \to \alpha$ ，其中，$P \in V_n$ ， $\alpha \in \left(V_t \bigcup V_n\right)^*$，开始符号 $S$ 必须在某个产生式的左边出现一次。

若干个左部相同的产生式，可以合并为一个。

$P \to \alpha_1$

$P \to \alpha_2$

$P \to \alpha_3$

可以合并，表示或，任意一个都可以

$P \to \alpha_1\mid \alpha_2 \mid \alpha_3 $

大写字母表示非终结符，小写字母表示终结符，希腊字母表示终结符和非终结符组成的符号串。

推导、句型、语言。