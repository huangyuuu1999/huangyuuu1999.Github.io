# 页表
虚拟内存是什么，为什么需要页表，页表保存了什么，页表和MMU如何配合？

## 虚拟内存
在每一个进程的视角，仿佛自己占用了“全部的内存”。———— 这里的内存指的就是虚拟内存。

因为程序的局部性，当前正在执行的代码只占内存的一点点，所以实际上，所谓的占用全部的内容，并不是真的占用。

虚拟内存和物理内存之间的映射关系，就需要有一个保存这个映射关系的地方，这就是页表。

## 页表

页表就是一个映射表，它一般存在于进程控制块PCB当中，当进程上CPU的时候，操作系统会把这个进程的页表起始地址放到特定的硬件当中，配合MMU来进行地址的翻译。

来谈谈页表映射的两个东西，一个是物理地址，一个是虚拟地址。

### 物理地址的划分
物理内存，按照特定的页面大小，例如4kb，切分为很多的小单元，这些单元称为物理页面。
这些单元有自己的编号。例如4GB的内存，如果按照4KB为一个页面来划分，就有2^20这么多页面。

### 虚拟地址的划分
虚拟地址的空间可以和物理地址一样，也可以不一样（在rv32I里面可以看到这一点）。但是划分的最小单元还是一样的，例如都是4KB，虚拟地址页面有时候也叫页框。总之虚拟页面可以和物理地址页面之间产生对应的关系，所谓的页表映射，也就是映射页面和页框。

### 页表项
页表实际上就像是一个大数组，它的index，就是虚拟地址的编号，所存的编号，就是物理页面的编号，就这么简单。

## 地址翻译过程

例如在代码中某处，要访问某个虚拟地址，这个虚拟地址，在分页了的虚拟地址中，一定在某个页框上，这个页框又对应一个实际的物理页面，经过MMU（内存管理单元）查询页表，就找到了实际的页面在物理内存上的位置，而这个地址在页框和页面上的位置，是一样的。

这个“地址在页框和页面上的位置” 叫做页内偏移offset。

## 多级页表

上面提到的，直接保存映射到页表中，查的时候也只需要直接查询页表。这种简单的模型就叫一级页表。
一级页表存在一个较明显的问题：
让我们假设现在有 4GB 的物理内存，每个页面的大小 设定为 4KB。
那么总共有 4GB = 2^32B 主存空间，每个最小单元（页面）占据 2^12B的 空间。总就有2^20个页面。
给0 - 2^20-1 标号，需要 20 个比特位。那么每个编号本身需要占据3个byte 也就是24bit。
当页表记录了很多项的时候（最多是2^20项），最大可能需要 2^20 * 3 byte = 3MB内存。
3MB内存相对于4GB来说，确实不算很多，但是要注意，页表是需要连续存放的，而连续存放的3MB，需要占据多少页页面？ 3MB / 4KB 约等于 1k个连续的页面，这是不现实的。

注意，上面假设使用3个byte来保存一个页面编号，实际上应该使用4KB，为了对齐。

为了解决这个 “太多连续页面” 不可能被提供的问题，就需要采用多级页表的技术。

## riscv的页表机制

## riscv页表相关硬件