# golang调度器

## GMP模型
GMP这三个字母是什么？
G -> goroutine 协程
P -> processor 处理器
M -> thread 物理线程

这三个东西在runtime里面都是结构体，都有自己的定义的。

### M的事情
用户进程是由操作系统来调度的，一个进程什么时候获得CPU等资源，是由操作系统来决定的。这一层是OS的调度层，go语言的调度层是在这一层上面的细粒度的调度层，要注意区分这两个调度。

这里的M说是线程，实际上在linux下面还是可以理解为进程，这都无关紧要。
M是在程序开始运行的时候自动创建的，数量是可以配置的，跟硬件有关，不同的go版本也不完全一样。
M可以休眠，也可以被销毁。

### P到底是干啥的？
P是处理器，协程就是一段代码，只有到了P上面才能执行起来，也就是说，P的任务就是获取G来执行它们的。
那么P从哪里获取G来执行呢？
有两个地方，一个就是每个P都有一个自己的本地队列，除此之外还有一个全局队列，这些队列里面的都是等待被执行的协程G。
![GMP模型](./GMP模型.png)
P的本地队列里面的协程是有一定的数量限制的。
优先将新创建的G放到本地队列中，如果满了，就放到全局队列中。

P在程序启动的时候，自动创建的，runtime里面。

### G对应协程
一个G协程一般对应一个要 `go func() { ... }` 的一个函数，这个函数就是一个协程任务。

## work stoling 偷取
当一个P结合M，空闲的时候，优先从其他P的本地队列偷取G执行，若其他也没有，可以从有锁的全局队列拿G来执行。
G是抢占式，每个G最多运行一段时间就要下CPU让出资源。

## hand off 移交
当某个P拿到G开始执行，执行的过程中发生了阻塞，不希望在此M上等待，可以带着自己的本地队列，转移到其他空闲的M上面执行。（复用线程）

## go func() {...} 发生了什么
执行 `go func() {...}` 的时候，先创建一个G，创建完优先放在当前运行的G的本地队列，如果满了，就放到全局队列。
如果到了本地队列之后，当排队排到了，P就会尝试获取这个G，到M上执行。

执行G的时候如果发生阻塞（系统调用或者阻塞，或者说中断了）了，就从休眠的M队列中获取M，没有就创建M，创建完了，让这个M接管P，去进行新的执行，原来阻塞的G就在远在的M上阻塞去。

## g0和m0
启动程序之后，编号为0的主线程就是m0，
这个m0保存在全局变量runtime.m0，不需要在heap上分配？啥意思

负责执行初始化操作，并启动第一个g

g0，每次启动一个M，都会第一个创建goroutine g0。
每一个M都有一个g0
g0的工作就是负责调度其他的g

在调度或者系统调用的时候，M都会先切换到g0，再来调度。
